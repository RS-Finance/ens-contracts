{
  "address": "0x05231e500570e84C81CcdB42Ea7D9B762331f8AD",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "key",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x21e41d61f2f9b04a613fbeb648e178c29b7be0c7ade712fa148e1ad4e8aa5073",
  "receipt": {
    "to": null,
    "from": "0x345A9cfC8C2A3C7689c07E18d9B0035EeC3eade1",
    "contractAddress": "0x05231e500570e84C81CcdB42Ea7D9B762331f8AD",
    "transactionIndex": 64,
    "gasUsed": "921746",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x64709c834483a6d2c567ec56bdb46bf52faf0b31ce0ca87ed5682d33763d0d9b",
    "transactionHash": "0x21e41d61f2f9b04a613fbeb648e178c29b7be0c7ade712fa148e1ad4e8aa5073",
    "logs": [],
    "blockNumber": 8078841,
    "cumulativeGasUsed": "10718621",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "20d0cf755bdff128bd31fe4809ab35fa",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"verify(bytes,bytes,bytes)\":{\"details\":\"Verifies a signature.\",\"params\":{\"data\":\"The signed data to verify.\",\"key\":\"The public key to verify with.\",\"signature\":\"The signature to verify.\"},\"returns\":{\"_0\":\"True iff the signature is valid.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol\":\"P256SHA256Algorithm\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2500},\"remappings\":[]},\"sources\":{\"contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\nlibrary BytesUtils {\\r\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the keccak-256 hash of a byte range.\\r\\n     * @param self The byte string to hash.\\r\\n     * @param offset The position to start hashing at.\\r\\n     * @param len The number of bytes to hash.\\r\\n     * @return The hash of the byte range.\\r\\n     */\\r\\n    function keccak(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(offset + len <= self.length);\\r\\n        assembly {\\r\\n            ret := keccak256(add(add(self, 32), offset), len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(bytes memory self, bytes memory other)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        return compare(self, 0, self.length, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\r\\n     *      on unicode codepoints.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param offset The offset of self.\\r\\n     * @param len    The length of self.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @param otheroffset The offset of the other string.\\r\\n     * @param otherlen    The length of the other string.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len,\\r\\n        bytes memory other,\\r\\n        uint256 otheroffset,\\r\\n        uint256 otherlen\\r\\n    ) internal pure returns (int256) {\\r\\n        if(offset + len > self.length) {\\r\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\r\\n        }\\r\\n        if(otheroffset + otherlen > other.length) {\\r\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\r\\n        }\\r\\n        \\r\\n        uint256 shortest = len;\\r\\n        if (otherlen < len) shortest = otherlen;\\r\\n\\r\\n        uint256 selfptr;\\r\\n        uint256 otherptr;\\r\\n\\r\\n        assembly {\\r\\n            selfptr := add(self, add(offset, 32))\\r\\n            otherptr := add(other, add(otheroffset, 32))\\r\\n        }\\r\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\r\\n            uint256 a;\\r\\n            uint256 b;\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n            if (a != b) {\\r\\n                // Mask out irrelevant bytes and check again\\r\\n                uint256 mask;\\r\\n                if (shortest - idx >= 32) {\\r\\n                    mask = type(uint256).max;\\r\\n                } else {\\r\\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\\r\\n                }\\r\\n                int256 diff = int256(a & mask) - int256(b & mask);\\r\\n                if (diff != 0) return diff;\\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n\\r\\n        return int256(len) - int256(otherlen);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @param len The number of bytes to compare\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bool) {\\r\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            keccak(self, offset, self.length - offset) ==\\r\\n            keccak(other, otherOffset, other.length - otherOffset);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\r\\n     *      they are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == offset + other.length &&\\r\\n            equals(self, offset, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(bytes memory self, bytes memory other)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        return\\r\\n            self.length == other.length &&\\r\\n            equals(self, 0, other, 0, self.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 8-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint8(bytes memory self, uint256 idx)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint8 ret)\\r\\n    {\\r\\n        return uint8(self[idx]);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 16-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint16(bytes memory self, uint256 idx)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint16 ret)\\r\\n    {\\r\\n        require(idx + 2 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint32(bytes memory self, uint256 idx)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint32 ret)\\r\\n    {\\r\\n        require(idx + 4 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes32(bytes memory self, uint256 idx)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32 ret)\\r\\n    {\\r\\n        require(idx + 32 <= self.length);\\r\\n        assembly {\\r\\n            ret := mload(add(add(self, 32), idx))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes20(bytes memory self, uint256 idx)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes20 ret)\\r\\n    {\\r\\n        require(idx + 20 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(\\r\\n                mload(add(add(self, 32), idx)),\\r\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the n byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes.\\r\\n     * @param len The number of bytes.\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytesN(\\r\\n        bytes memory self,\\r\\n        uint256 idx,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(len <= 32);\\r\\n        require(idx + len <= self.length);\\r\\n        assembly {\\r\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\r\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function memcpy(\\r\\n        uint256 dest,\\r\\n        uint256 src,\\r\\n        uint256 len\\r\\n    ) private pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for (; len >= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        unchecked {\\r\\n            uint256 mask = (256**(32 - len)) - 1;\\r\\n            assembly {\\r\\n                let srcpart := and(mload(src), not(mask))\\r\\n                let destpart := and(mload(dest), mask)\\r\\n                mstore(dest, or(destpart, srcpart))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Copies a substring into a new byte string.\\r\\n     * @param self The byte string to copy from.\\r\\n     * @param offset The offset to start copying at.\\r\\n     * @param len The number of bytes to copy.\\r\\n     */\\r\\n    function substring(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        require(offset + len <= self.length);\\r\\n\\r\\n        bytes memory ret = new bytes(len);\\r\\n        uint256 dest;\\r\\n        uint256 src;\\r\\n\\r\\n        assembly {\\r\\n            dest := add(ret, 32)\\r\\n            src := add(add(self, 32), offset)\\r\\n        }\\r\\n        memcpy(dest, src, len);\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\r\\n    // 0xFF represents invalid characters in that range.\\r\\n    bytes constant base32HexTable =\\r\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\r\\n     * @param self The data to decode.\\r\\n     * @param off Offset into the string to start at.\\r\\n     * @param len Number of characters to decode.\\r\\n     * @return The decoded data, left aligned.\\r\\n     */\\r\\n    function base32HexDecodeWord(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(len <= 52);\\r\\n\\r\\n        uint256 ret = 0;\\r\\n        uint8 decoded;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            bytes1 char = self[off + i];\\r\\n            require(char >= 0x30 && char <= 0x7A);\\r\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\r\\n            require(decoded <= 0x20);\\r\\n            if (i == len - 1) {\\r\\n                break;\\r\\n            }\\r\\n            ret = (ret << 5) | decoded;\\r\\n        }\\r\\n\\r\\n        uint256 bitlen = len * 5;\\r\\n        if (len % 8 == 0) {\\r\\n            // Multiple of 8 characters, no padding\\r\\n            ret = (ret << 5) | decoded;\\r\\n        } else if (len % 8 == 2) {\\r\\n            // Two extra characters - 1 byte\\r\\n            ret = (ret << 3) | (decoded >> 2);\\r\\n            bitlen -= 2;\\r\\n        } else if (len % 8 == 4) {\\r\\n            // Four extra characters - 2 bytes\\r\\n            ret = (ret << 1) | (decoded >> 4);\\r\\n            bitlen -= 4;\\r\\n        } else if (len % 8 == 5) {\\r\\n            // Five extra characters - 3 bytes\\r\\n            ret = (ret << 4) | (decoded >> 1);\\r\\n            bitlen -= 1;\\r\\n        } else if (len % 8 == 7) {\\r\\n            // Seven extra characters - 4 bytes\\r\\n            ret = (ret << 2) | (decoded >> 3);\\r\\n            bitlen -= 3;\\r\\n        } else {\\r\\n            revert();\\r\\n        }\\r\\n\\r\\n        return bytes32(ret << (256 - bitlen));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\\r\\n     * @param self The string to search\\r\\n     * @param off The offset to start searching at\\r\\n     * @param len The number of bytes to search\\r\\n     * @param needle The byte to search for\\r\\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\r\\n     */\\r\\n    function find(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len,\\r\\n        bytes1 needle\\r\\n    ) internal pure returns (uint256) {\\r\\n        for (uint256 idx = off; idx < off + len; idx++) {\\r\\n            if (self[idx] == needle) {\\r\\n                return idx;\\r\\n            }\\r\\n        }\\r\\n        return type(uint256).max;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x805ebf16dec9650ae9cf80381e036426d1382036e0bb534b119e4a9e27122633\"},\"contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\r\\n */\\r\\ninterface Algorithm {\\r\\n    /**\\r\\n     * @dev Verifies a signature.\\r\\n     * @param key The public key to verify with.\\r\\n     * @param data The signed data to verify.\\r\\n     * @param signature The signature to verify.\\r\\n     * @return True iff the signature is valid.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes calldata key,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external view virtual returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x244a3d2e6290b47d2f0097c7562073180cbbcb095eea071652cf34effe918da0\"},\"contracts/dnssec-oracle/algorithms/EllipticCurve.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @title   EllipticCurve\\r\\n *\\r\\n * @author  Tilman Drerup;\\r\\n *\\r\\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\\r\\n *\\r\\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\\r\\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\\r\\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\\r\\n *\\r\\n *          Source: https://github.com/tdrerup/elliptic-curve-solidity\\r\\n *\\r\\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\\r\\n *          condition 'rs[1] > lowSmax' in validateSignature().\\r\\n */\\r\\ncontract EllipticCurve {\\r\\n    // Set parameters for curve.\\r\\n    uint256 constant a =\\r\\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\\r\\n    uint256 constant b =\\r\\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\\r\\n    uint256 constant gx =\\r\\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\\r\\n    uint256 constant gy =\\r\\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\\r\\n    uint256 constant p =\\r\\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n    uint256 constant n =\\r\\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\\r\\n\\r\\n    uint256 constant lowSmax =\\r\\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\\r\\n\\r\\n    /**\\r\\n     * @dev Inverse of u in the field of modulo m.\\r\\n     */\\r\\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            if (u == 0 || u == m || m == 0) return 0;\\r\\n            if (u > m) u = u % m;\\r\\n\\r\\n            int256 t1;\\r\\n            int256 t2 = 1;\\r\\n            uint256 r1 = m;\\r\\n            uint256 r2 = u;\\r\\n            uint256 q;\\r\\n\\r\\n            while (r2 != 0) {\\r\\n                q = r1 / r2;\\r\\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\\r\\n            }\\r\\n\\r\\n            if (t1 < 0) return (m - uint256(-t1));\\r\\n\\r\\n            return uint256(t1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transform affine coordinates into projective coordinates.\\r\\n     */\\r\\n    function toProjectivePoint(uint256 x0, uint256 y0)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256[3] memory P)\\r\\n    {\\r\\n        P[2] = addmod(0, 1, p);\\r\\n        P[0] = mulmod(x0, P[2], p);\\r\\n        P[1] = mulmod(y0, P[2], p);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add two points in affine coordinates and return projective point.\\r\\n     */\\r\\n    function addAndReturnProjectivePoint(\\r\\n        uint256 x1,\\r\\n        uint256 y1,\\r\\n        uint256 x2,\\r\\n        uint256 y2\\r\\n    ) internal pure returns (uint256[3] memory P) {\\r\\n        uint256 x;\\r\\n        uint256 y;\\r\\n        (x, y) = add(x1, y1, x2, y2);\\r\\n        P = toProjectivePoint(x, y);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transform from projective to affine coordinates.\\r\\n     */\\r\\n    function toAffinePoint(\\r\\n        uint256 x0,\\r\\n        uint256 y0,\\r\\n        uint256 z0\\r\\n    ) internal pure returns (uint256 x1, uint256 y1) {\\r\\n        uint256 z0Inv;\\r\\n        z0Inv = inverseMod(z0, p);\\r\\n        x1 = mulmod(x0, z0Inv, p);\\r\\n        y1 = mulmod(y0, z0Inv, p);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the zero curve in projective coordinates.\\r\\n     */\\r\\n    function zeroProj()\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 x,\\r\\n            uint256 y,\\r\\n            uint256 z\\r\\n        )\\r\\n    {\\r\\n        return (0, 1, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the zero curve in affine coordinates.\\r\\n     */\\r\\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\\r\\n        return (0, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if the curve is the zero curve.\\r\\n     */\\r\\n    function isZeroCurve(uint256 x0, uint256 y0)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool isZero)\\r\\n    {\\r\\n        if (x0 == 0 && y0 == 0) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if a point in affine coordinates is on the curve.\\r\\n     */\\r\\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\\r\\n        if (0 == x || x == p || 0 == y || y == p) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        uint256 LHS = mulmod(y, y, p); // y^2\\r\\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\\r\\n\\r\\n        if (a != 0) {\\r\\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\\r\\n        }\\r\\n        if (b != 0) {\\r\\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\\r\\n        }\\r\\n\\r\\n        return LHS == RHS;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Double an elliptic curve point in projective coordinates. See\\r\\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\\r\\n     */\\r\\n    function twiceProj(\\r\\n        uint256 x0,\\r\\n        uint256 y0,\\r\\n        uint256 z0\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 x1,\\r\\n            uint256 y1,\\r\\n            uint256 z1\\r\\n        )\\r\\n    {\\r\\n        uint256 t;\\r\\n        uint256 u;\\r\\n        uint256 v;\\r\\n        uint256 w;\\r\\n\\r\\n        if (isZeroCurve(x0, y0)) {\\r\\n            return zeroProj();\\r\\n        }\\r\\n\\r\\n        u = mulmod(y0, z0, p);\\r\\n        u = mulmod(u, 2, p);\\r\\n\\r\\n        v = mulmod(u, x0, p);\\r\\n        v = mulmod(v, y0, p);\\r\\n        v = mulmod(v, 2, p);\\r\\n\\r\\n        x0 = mulmod(x0, x0, p);\\r\\n        t = mulmod(x0, 3, p);\\r\\n\\r\\n        z0 = mulmod(z0, z0, p);\\r\\n        z0 = mulmod(z0, a, p);\\r\\n        t = addmod(t, z0, p);\\r\\n\\r\\n        w = mulmod(t, t, p);\\r\\n        x0 = mulmod(2, v, p);\\r\\n        w = addmod(w, p - x0, p);\\r\\n\\r\\n        x0 = addmod(v, p - w, p);\\r\\n        x0 = mulmod(t, x0, p);\\r\\n        y0 = mulmod(y0, u, p);\\r\\n        y0 = mulmod(y0, y0, p);\\r\\n        y0 = mulmod(2, y0, p);\\r\\n        y1 = addmod(x0, p - y0, p);\\r\\n\\r\\n        x1 = mulmod(u, w, p);\\r\\n\\r\\n        z1 = mulmod(u, u, p);\\r\\n        z1 = mulmod(z1, u, p);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add two elliptic curve points in projective coordinates. See\\r\\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\\r\\n     */\\r\\n    function addProj(\\r\\n        uint256 x0,\\r\\n        uint256 y0,\\r\\n        uint256 z0,\\r\\n        uint256 x1,\\r\\n        uint256 y1,\\r\\n        uint256 z1\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 x2,\\r\\n            uint256 y2,\\r\\n            uint256 z2\\r\\n        )\\r\\n    {\\r\\n        uint256 t0;\\r\\n        uint256 t1;\\r\\n        uint256 u0;\\r\\n        uint256 u1;\\r\\n\\r\\n        if (isZeroCurve(x0, y0)) {\\r\\n            return (x1, y1, z1);\\r\\n        } else if (isZeroCurve(x1, y1)) {\\r\\n            return (x0, y0, z0);\\r\\n        }\\r\\n\\r\\n        t0 = mulmod(y0, z1, p);\\r\\n        t1 = mulmod(y1, z0, p);\\r\\n\\r\\n        u0 = mulmod(x0, z1, p);\\r\\n        u1 = mulmod(x1, z0, p);\\r\\n\\r\\n        if (u0 == u1) {\\r\\n            if (t0 == t1) {\\r\\n                return twiceProj(x0, y0, z0);\\r\\n            } else {\\r\\n                return zeroProj();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Helper function that splits addProj to avoid too many local variables.\\r\\n     */\\r\\n    function addProj2(\\r\\n        uint256 v,\\r\\n        uint256 u0,\\r\\n        uint256 u1,\\r\\n        uint256 t1,\\r\\n        uint256 t0\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 x2,\\r\\n            uint256 y2,\\r\\n            uint256 z2\\r\\n        )\\r\\n    {\\r\\n        uint256 u;\\r\\n        uint256 u2;\\r\\n        uint256 u3;\\r\\n        uint256 w;\\r\\n        uint256 t;\\r\\n\\r\\n        t = addmod(t0, p - t1, p);\\r\\n        u = addmod(u0, p - u1, p);\\r\\n        u2 = mulmod(u, u, p);\\r\\n\\r\\n        w = mulmod(t, t, p);\\r\\n        w = mulmod(w, v, p);\\r\\n        u1 = addmod(u1, u0, p);\\r\\n        u1 = mulmod(u1, u2, p);\\r\\n        w = addmod(w, p - u1, p);\\r\\n\\r\\n        x2 = mulmod(u, w, p);\\r\\n\\r\\n        u3 = mulmod(u2, u, p);\\r\\n        u0 = mulmod(u0, u2, p);\\r\\n        u0 = addmod(u0, p - w, p);\\r\\n        t = mulmod(t, u0, p);\\r\\n        t0 = mulmod(t0, u3, p);\\r\\n\\r\\n        y2 = addmod(t, p - t0, p);\\r\\n\\r\\n        z2 = mulmod(u3, v, p);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add two elliptic curve points in affine coordinates.\\r\\n     */\\r\\n    function add(\\r\\n        uint256 x0,\\r\\n        uint256 y0,\\r\\n        uint256 x1,\\r\\n        uint256 y1\\r\\n    ) internal pure returns (uint256, uint256) {\\r\\n        uint256 z0;\\r\\n\\r\\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\\r\\n\\r\\n        return toAffinePoint(x0, y0, z0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Double an elliptic curve point in affine coordinates.\\r\\n     */\\r\\n    function twice(uint256 x0, uint256 y0)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        uint256 z0;\\r\\n\\r\\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\\r\\n\\r\\n        return toAffinePoint(x0, y0, z0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\\r\\n     */\\r\\n    function multiplyPowerBase2(\\r\\n        uint256 x0,\\r\\n        uint256 y0,\\r\\n        uint256 exp\\r\\n    ) internal pure returns (uint256, uint256) {\\r\\n        uint256 base2X = x0;\\r\\n        uint256 base2Y = y0;\\r\\n        uint256 base2Z = 1;\\r\\n\\r\\n        for (uint256 i = 0; i < exp; i++) {\\r\\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\\r\\n        }\\r\\n\\r\\n        return toAffinePoint(base2X, base2Y, base2Z);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an elliptic curve point by a scalar.\\r\\n     */\\r\\n    function multiplyScalar(\\r\\n        uint256 x0,\\r\\n        uint256 y0,\\r\\n        uint256 scalar\\r\\n    ) internal pure returns (uint256 x1, uint256 y1) {\\r\\n        if (scalar == 0) {\\r\\n            return zeroAffine();\\r\\n        } else if (scalar == 1) {\\r\\n            return (x0, y0);\\r\\n        } else if (scalar == 2) {\\r\\n            return twice(x0, y0);\\r\\n        }\\r\\n\\r\\n        uint256 base2X = x0;\\r\\n        uint256 base2Y = y0;\\r\\n        uint256 base2Z = 1;\\r\\n        uint256 z1 = 1;\\r\\n        x1 = x0;\\r\\n        y1 = y0;\\r\\n\\r\\n        if (scalar % 2 == 0) {\\r\\n            x1 = y1 = 0;\\r\\n        }\\r\\n\\r\\n        scalar = scalar >> 1;\\r\\n\\r\\n        while (scalar > 0) {\\r\\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\\r\\n\\r\\n            if (scalar % 2 == 1) {\\r\\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\\r\\n            }\\r\\n\\r\\n            scalar = scalar >> 1;\\r\\n        }\\r\\n\\r\\n        return toAffinePoint(x1, y1, z1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply the curve's generator point by a scalar.\\r\\n     */\\r\\n    function multipleGeneratorByScalar(uint256 scalar)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return multiplyScalar(gx, gy, scalar);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validate combination of message, signature, and public key.\\r\\n     */\\r\\n    function validateSignature(\\r\\n        bytes32 message,\\r\\n        uint256[2] memory rs,\\r\\n        uint256[2] memory Q\\r\\n    ) internal pure returns (bool) {\\r\\n        // To disambiguate between public key solutions, include comment below.\\r\\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\\r\\n            // || rs[1] > lowSmax)\\r\\n            return false;\\r\\n        }\\r\\n        if (!isOnCurve(Q[0], Q[1])) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        uint256 x1;\\r\\n        uint256 x2;\\r\\n        uint256 y1;\\r\\n        uint256 y2;\\r\\n\\r\\n        uint256 sInv = inverseMod(rs[1], n);\\r\\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\\r\\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\\r\\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\\r\\n\\r\\n        if (P[2] == 0) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        uint256 Px = inverseMod(P[2], p);\\r\\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\\r\\n\\r\\n        return Px % n == rs[0];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xdb741230defb1f1311531884547e2cb7445862bb90a504151ce489540ece2503\"},\"contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Algorithm.sol\\\";\\r\\nimport \\\"./EllipticCurve.sol\\\";\\r\\nimport \\\"../BytesUtils.sol\\\";\\r\\n\\r\\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\\r\\n    using BytesUtils for *;\\r\\n\\r\\n    /**\\r\\n     * @dev Verifies a signature.\\r\\n     * @param key The public key to verify with.\\r\\n     * @param data The signed data to verify.\\r\\n     * @param signature The signature to verify.\\r\\n     * @return True iff the signature is valid.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes calldata key,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external view override returns (bool) {\\r\\n        return\\r\\n            validateSignature(\\r\\n                sha256(data),\\r\\n                parseSignature(signature),\\r\\n                parseKey(key)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function parseSignature(bytes memory data)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256[2] memory)\\r\\n    {\\r\\n        require(data.length == 64, \\\"Invalid p256 signature length\\\");\\r\\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\\r\\n    }\\r\\n\\r\\n    function parseKey(bytes memory data)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256[2] memory)\\r\\n    {\\r\\n        require(data.length == 68, \\\"Invalid p256 key length\\\");\\r\\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xf1cabdc1677108bd00fb11c6223fb55d0a009f021619b65a37ef6cd9085c1c94\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610fc0806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063de8f50a114610030575b600080fd5b61004361003e366004610e08565b610057565b604051901515815260200160405180910390f35b60006101316002868660405161006e929190610ea2565b602060405180830381855afa15801561008b573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906100ae9190610eb2565b6100ed85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061013c92505050565b61012c8a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506101e592505050565b61027e565b979650505050505050565b610144610d8a565b81516040146101b4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f496e76616c69642070323536207369676e6174757265206c656e67746800000060448201526064015b60405180910390fd5b60408051808201909152806101ca846000610479565b81526020908101906101dd908590610479565b905292915050565b6101ed610d8a565b8151604414610258576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f496e76616c69642070323536206b6579206c656e67746800000000000000000060448201526064016101ab565b604080518082019091528061026e846004610479565b81526020016101dd846024610479565b815160009015806102b0575082517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255111155b806102bd57506020830151155b156102ca57506000610472565b815160208301516102db919061049d565b6102e757506000610472565b60008080808061031e88600160200201517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551610599565b905061038e7f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2967f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f57fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551848d09610633565b885160208a01518b519398509195506103ce929091907fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255190859009610633565b909450915060006103e186858786610703565b60408101519091506000036103ff5760009650505050505050610472565b60006104208260026020020151600160601b63ffffffff60c01b0319610599565b9050600160601b63ffffffff60c01b0319808283098351098a519091506104677fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255183610efa565b149750505050505050505b9392505050565b8151600090610489836020610f64565b111561049457600080fd5b50016020015190565b60008215806104b95750600160601b63ffffffff60c01b031983145b806104c2575081155b806104da5750600160601b63ffffffff60c01b031982145b156104e757506000610593565b6000600160601b63ffffffff60c01b031983840990506000600160601b63ffffffff60c01b031985600160601b63ffffffff60c01b0319878809099050600160601b63ffffffff60c01b0319807fffffffff00000001000000000000000000000000fffffffffffffffffffffffc870982089050600160601b63ffffffff60c01b03197f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b820890501490505b92915050565b60008215806105a757508183145b806105b0575081155b156105bd57506000610593565b818311156105d8578183816105d4576105d4610ecb565b0692505b600060018385835b811561060f578183816105f5576105f5610ecb565b9495940485810290940393919283830290039190506105e0565b60008512156106275750505090830191506105939050565b50929695505050505050565b6000808260000361064b576000805b915091506106fb565b8260010361065d5750839050826106fb565b8260020361066f576106428585610729565b50839050828181600180610684600288610efa565b60000361069357600094508495505b600187901c96505b86156106e7576106ac848484610759565b919550935091506106be600288610efa565b6001036106db576106d38484848989866109b7565b919750955090505b600187901c965061069b565b6106f2868683610abc565b95509550505050505b935093915050565b61070b610da8565b60008061071a87878787610b0c565b90925090506101318282610b41565b600080600061073a85856001610759565b9196509450905061074c858583610abc565b92509250505b9250929050565b600080600080600080600061076e8a8a610b9a565b15610787576000600181965096509650505050506109ae565b600160601b63ffffffff60c01b0319888a099250600160601b63ffffffff60c01b0319600284099250600160601b63ffffffff60c01b03198a84099150600160601b63ffffffff60c01b03198983099150600160601b63ffffffff60c01b0319600283099150600160601b63ffffffff60c01b03198a8b099950600160601b63ffffffff60c01b031960038b099350600160601b63ffffffff60c01b03198889099750600160601b63ffffffff60c01b03197fffffffff00000001000000000000000000000000fffffffffffffffffffffffc89099750600160601b63ffffffff60c01b03198885089350600160601b63ffffffff60c01b03198485099050600160601b63ffffffff60c01b0319826002099950600160601b63ffffffff60c01b03196108c28b600160601b63ffffffff60c01b0319610f77565b82089050600160601b63ffffffff60c01b03196108ed82600160601b63ffffffff60c01b0319610f77565b83089950600160601b63ffffffff60c01b03198a85099950600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319898a099850600160601b63ffffffff60c01b0319896002099850600160601b63ffffffff60c01b03196109698a600160601b63ffffffff60c01b0319610f77565b8b089550600160601b63ffffffff60c01b03198184099650600160601b63ffffffff60c01b03198384099450600160601b63ffffffff60c01b03198386099450505050505b93509350939050565b60008060008060008060006109cc8d8d610b9a565b156109e35789898996509650965050505050610ab0565b6109ed8a8a610b9a565b15610a04578c8c8c96509650965050505050610ab0565b600160601b63ffffffff60c01b0319888d099350600160601b63ffffffff60c01b03198b8a099250600160601b63ffffffff60c01b0319888e099150600160601b63ffffffff60c01b03198b8b099050808203610a8657828403610a7c57610a6d8d8d8d610759565b96509650965050505050610ab0565b6000600181610a6d565b610aa4600160601b63ffffffff60c01b0319898d0983838688610bbe565b91985096509450505050505b96509650969350505050565b6000806000610ad984600160601b63ffffffff60c01b0319610599565b9050600160601b63ffffffff60c01b03198187099250600160601b63ffffffff60c01b0319818609915050935093915050565b6000806000610b2187876001888860016109b7565b91985096509050610b33878783610abc565b925092505094509492505050565b610b49610da8565b600160601b63ffffffff60c01b0319600160000860408201819052600160601b63ffffffff60c01b031990840981526040810151600160601b63ffffffff60c01b0319908309602082015292915050565b600082158015610ba8575081155b15610bb557506001610593565b50600092915050565b600080808080808080600160601b63ffffffff60c01b0319610bee8b600160601b63ffffffff60c01b0319610f77565b8a089050600160601b63ffffffff60c01b0319610c198c600160601b63ffffffff60c01b0319610f77565b8d089450600160601b63ffffffff60c01b03198586099350600160601b63ffffffff60c01b03198182099150600160601b63ffffffff60c01b03198d83099150600160601b63ffffffff60c01b03198c8c089a50600160601b63ffffffff60c01b0319848c099a50600160601b63ffffffff60c01b0319610ca88c600160601b63ffffffff60c01b0319610f77565b83089150600160601b63ffffffff60c01b03198286099750600160601b63ffffffff60c01b03198585099250600160601b63ffffffff60c01b0319848d099b50600160601b63ffffffff60c01b0319610d0f83600160601b63ffffffff60c01b0319610f77565b8d089b50600160601b63ffffffff60c01b03198c82099050600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319610d628a600160601b63ffffffff60c01b0319610f77565b82089650600160601b63ffffffff60c01b03198d840995505050505050955095509592505050565b60405180604001604052806002906020820280368337509192915050565b60405180606001604052806003906020820280368337509192915050565b60008083601f840112610dd857600080fd5b50813567ffffffffffffffff811115610df057600080fd5b60208301915083602082850101111561075257600080fd5b60008060008060008060608789031215610e2157600080fd5b863567ffffffffffffffff80821115610e3957600080fd5b610e458a838b01610dc6565b90985096506020890135915080821115610e5e57600080fd5b610e6a8a838b01610dc6565b90965094506040890135915080821115610e8357600080fd5b50610e9089828a01610dc6565b979a9699509497509295939492505050565b8183823760009101908152919050565b600060208284031215610ec457600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082610f30577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561059357610593610f35565b8181038181111561059357610593610f3556fea26469706673582212204a68ad99d749a6c606b81c1a3c801fd61b9f79f901cf59efceac2aea5d0cbf2164736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063de8f50a114610030575b600080fd5b61004361003e366004610e08565b610057565b604051901515815260200160405180910390f35b60006101316002868660405161006e929190610ea2565b602060405180830381855afa15801561008b573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906100ae9190610eb2565b6100ed85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061013c92505050565b61012c8a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506101e592505050565b61027e565b979650505050505050565b610144610d8a565b81516040146101b4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f496e76616c69642070323536207369676e6174757265206c656e67746800000060448201526064015b60405180910390fd5b60408051808201909152806101ca846000610479565b81526020908101906101dd908590610479565b905292915050565b6101ed610d8a565b8151604414610258576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f496e76616c69642070323536206b6579206c656e67746800000000000000000060448201526064016101ab565b604080518082019091528061026e846004610479565b81526020016101dd846024610479565b815160009015806102b0575082517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255111155b806102bd57506020830151155b156102ca57506000610472565b815160208301516102db919061049d565b6102e757506000610472565b60008080808061031e88600160200201517fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551610599565b905061038e7f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2967f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f57fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551848d09610633565b885160208a01518b519398509195506103ce929091907fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255190859009610633565b909450915060006103e186858786610703565b60408101519091506000036103ff5760009650505050505050610472565b60006104208260026020020151600160601b63ffffffff60c01b0319610599565b9050600160601b63ffffffff60c01b0319808283098351098a519091506104677fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63255183610efa565b149750505050505050505b9392505050565b8151600090610489836020610f64565b111561049457600080fd5b50016020015190565b60008215806104b95750600160601b63ffffffff60c01b031983145b806104c2575081155b806104da5750600160601b63ffffffff60c01b031982145b156104e757506000610593565b6000600160601b63ffffffff60c01b031983840990506000600160601b63ffffffff60c01b031985600160601b63ffffffff60c01b0319878809099050600160601b63ffffffff60c01b0319807fffffffff00000001000000000000000000000000fffffffffffffffffffffffc870982089050600160601b63ffffffff60c01b03197f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b820890501490505b92915050565b60008215806105a757508183145b806105b0575081155b156105bd57506000610593565b818311156105d8578183816105d4576105d4610ecb565b0692505b600060018385835b811561060f578183816105f5576105f5610ecb565b9495940485810290940393919283830290039190506105e0565b60008512156106275750505090830191506105939050565b50929695505050505050565b6000808260000361064b576000805b915091506106fb565b8260010361065d5750839050826106fb565b8260020361066f576106428585610729565b50839050828181600180610684600288610efa565b60000361069357600094508495505b600187901c96505b86156106e7576106ac848484610759565b919550935091506106be600288610efa565b6001036106db576106d38484848989866109b7565b919750955090505b600187901c965061069b565b6106f2868683610abc565b95509550505050505b935093915050565b61070b610da8565b60008061071a87878787610b0c565b90925090506101318282610b41565b600080600061073a85856001610759565b9196509450905061074c858583610abc565b92509250505b9250929050565b600080600080600080600061076e8a8a610b9a565b15610787576000600181965096509650505050506109ae565b600160601b63ffffffff60c01b0319888a099250600160601b63ffffffff60c01b0319600284099250600160601b63ffffffff60c01b03198a84099150600160601b63ffffffff60c01b03198983099150600160601b63ffffffff60c01b0319600283099150600160601b63ffffffff60c01b03198a8b099950600160601b63ffffffff60c01b031960038b099350600160601b63ffffffff60c01b03198889099750600160601b63ffffffff60c01b03197fffffffff00000001000000000000000000000000fffffffffffffffffffffffc89099750600160601b63ffffffff60c01b03198885089350600160601b63ffffffff60c01b03198485099050600160601b63ffffffff60c01b0319826002099950600160601b63ffffffff60c01b03196108c28b600160601b63ffffffff60c01b0319610f77565b82089050600160601b63ffffffff60c01b03196108ed82600160601b63ffffffff60c01b0319610f77565b83089950600160601b63ffffffff60c01b03198a85099950600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319898a099850600160601b63ffffffff60c01b0319896002099850600160601b63ffffffff60c01b03196109698a600160601b63ffffffff60c01b0319610f77565b8b089550600160601b63ffffffff60c01b03198184099650600160601b63ffffffff60c01b03198384099450600160601b63ffffffff60c01b03198386099450505050505b93509350939050565b60008060008060008060006109cc8d8d610b9a565b156109e35789898996509650965050505050610ab0565b6109ed8a8a610b9a565b15610a04578c8c8c96509650965050505050610ab0565b600160601b63ffffffff60c01b0319888d099350600160601b63ffffffff60c01b03198b8a099250600160601b63ffffffff60c01b0319888e099150600160601b63ffffffff60c01b03198b8b099050808203610a8657828403610a7c57610a6d8d8d8d610759565b96509650965050505050610ab0565b6000600181610a6d565b610aa4600160601b63ffffffff60c01b0319898d0983838688610bbe565b91985096509450505050505b96509650969350505050565b6000806000610ad984600160601b63ffffffff60c01b0319610599565b9050600160601b63ffffffff60c01b03198187099250600160601b63ffffffff60c01b0319818609915050935093915050565b6000806000610b2187876001888860016109b7565b91985096509050610b33878783610abc565b925092505094509492505050565b610b49610da8565b600160601b63ffffffff60c01b0319600160000860408201819052600160601b63ffffffff60c01b031990840981526040810151600160601b63ffffffff60c01b0319908309602082015292915050565b600082158015610ba8575081155b15610bb557506001610593565b50600092915050565b600080808080808080600160601b63ffffffff60c01b0319610bee8b600160601b63ffffffff60c01b0319610f77565b8a089050600160601b63ffffffff60c01b0319610c198c600160601b63ffffffff60c01b0319610f77565b8d089450600160601b63ffffffff60c01b03198586099350600160601b63ffffffff60c01b03198182099150600160601b63ffffffff60c01b03198d83099150600160601b63ffffffff60c01b03198c8c089a50600160601b63ffffffff60c01b0319848c099a50600160601b63ffffffff60c01b0319610ca88c600160601b63ffffffff60c01b0319610f77565b83089150600160601b63ffffffff60c01b03198286099750600160601b63ffffffff60c01b03198585099250600160601b63ffffffff60c01b0319848d099b50600160601b63ffffffff60c01b0319610d0f83600160601b63ffffffff60c01b0319610f77565b8d089b50600160601b63ffffffff60c01b03198c82099050600160601b63ffffffff60c01b0319838a099850600160601b63ffffffff60c01b0319610d628a600160601b63ffffffff60c01b0319610f77565b82089650600160601b63ffffffff60c01b03198d840995505050505050955095509592505050565b60405180604001604052806002906020820280368337509192915050565b60405180606001604052806003906020820280368337509192915050565b60008083601f840112610dd857600080fd5b50813567ffffffffffffffff811115610df057600080fd5b60208301915083602082850101111561075257600080fd5b60008060008060008060608789031215610e2157600080fd5b863567ffffffffffffffff80821115610e3957600080fd5b610e458a838b01610dc6565b90985096506020890135915080821115610e5e57600080fd5b610e6a8a838b01610dc6565b90965094506040890135915080821115610e8357600080fd5b50610e9089828a01610dc6565b979a9699509497509295939492505050565b8183823760009101908152919050565b600060208284031215610ec457600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082610f30577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561059357610593610f35565b8181038181111561059357610593610f3556fea26469706673582212204a68ad99d749a6c606b81c1a3c801fd61b9f79f901cf59efceac2aea5d0cbf2164736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "verify(bytes,bytes,bytes)": {
        "details": "Verifies a signature.",
        "params": {
          "data": "The signed data to verify.",
          "key": "The public key to verify with.",
          "signature": "The signature to verify."
        },
        "returns": {
          "_0": "True iff the signature is valid."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}